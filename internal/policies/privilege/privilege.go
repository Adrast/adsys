package privilege

import (
	"context"
	"fmt"
	"os"
	"path/filepath"
	"strings"
	"sync"

	"github.com/ubuntu/adsys/internal/consts"
	"github.com/ubuntu/adsys/internal/decorate"
	log "github.com/ubuntu/adsys/internal/grpc/logstreamer"
	"github.com/ubuntu/adsys/internal/i18n"
	"github.com/ubuntu/adsys/internal/policies/entry"
)

/*
	Notes:
	privilege allows and deny privilege escalation on the client.

	It does so in modifying policykit and sudo files to override default distribution rules.

	This is all or nothing, similarly to the sudo policy files in most default distribution setup.

	We are modifying 2 files:
	- one for sudo, named 99-adsys-privilege-enforcement in sudoers.d
	- one under 99-adsys-privilege-enforcement.conf and 90-mandatory.d/99-adsys-privilege-enforcement.pkla for policykit

	Both are installed in /etc.
*/

// Manager prevents running multiple privilege update process in parallel while parsing policy in ApplyPolicy.
type Manager struct {
	privilegeMu sync.RWMutex

	sudoersDir   string
	policyKitDir string
}

// NewWithDirs creates a manager with a specific root directory.
func NewWithDirs(sudoersDir, policyKitDir string) *Manager {
	return &Manager{
		sudoersDir:   sudoersDir,
		policyKitDir: policyKitDir,
	}
}

// ApplyPolicy generates a privilege policy based on a list of entries.
func (m *Manager) ApplyPolicy(ctx context.Context, objectName string, isComputer bool, entries []entry.Entry) (err error) {
	defer decorate.OnError(&err, i18n.G("can't apply privilege policy to %s"), objectName)

	// We only have privilege escalation on computers.
	if !isComputer {
		return nil
	}

	sudoersDir := m.sudoersDir
	if sudoersDir == "" {
		sudoersDir = consts.DefaultSudoersDir
	}
	policyKitDir := m.policyKitDir
	if policyKitDir == "" {
		policyKitDir = consts.DefaultPolicyKitDir
	}
	sudoersConf := filepath.Join(sudoersDir, "99-adsys-privilege-enforcement")
	policyKitConf := filepath.Join(policyKitDir, "localauthority.conf.d", "99-adsys-privilege-enforcement.conf")
	policyKitRules := filepath.Join(policyKitDir, "localauthority", "90-mandatory.d", "99-adsys-privilege-enforcement.pkla")

	m.privilegeMu.RLock()
	defer m.privilegeMu.RUnlock()

	log.Debugf(ctx, "Applying privilege policy to %s", objectName)

	// Create our temp files and parent directories
	if err := os.MkdirAll(filepath.Dir(sudoersConf), 0755); err != nil {
		return err
	}
	sudoersF, err := os.OpenFile(sudoersConf+".new", os.O_RDWR|os.O_CREATE|os.O_TRUNC, 0440)
	if err != nil {
		return err
	}
	defer sudoersF.Close()
	if err := os.MkdirAll(filepath.Dir(policyKitConf), 0755); err != nil {
		return err
	}
	policyKitConfF, err := os.OpenFile(policyKitConf+".new", os.O_RDWR|os.O_CREATE|os.O_TRUNC, 0644)
	if err != nil {
		return err
	}
	defer policyKitConfF.Close()
	if err := os.MkdirAll(filepath.Dir(policyKitRules), 0700); err != nil {
		return err
	}
	policyKitRulesF, err := os.OpenFile(policyKitRules+".new", os.O_RDWR|os.O_CREATE|os.O_TRUNC, 0600)
	if err != nil {
		return err
	}
	defer policyKitRulesF.Close()

	// Parse our rules and write to temp files
	var headerWritten bool
	for _, entry := range entries {
		var contentSudo, contentPolicyKitConf, contentPolicyKitRules string

		if !headerWritten {
			h := `# This file is managed by adsys.
# Do not edit this file manually.
# Any changes will be overwritten.

`
			contentSudo, contentPolicyKitConf, contentPolicyKitRules = h, h, h
			headerWritten = true
		}

		switch entry.Key {
		case "allow-local-admins":
			if !entry.Disabled {
				continue
			}
			contentSudo += "%admin	ALL=(ALL) !ALL\n"
			contentSudo += "%sudo	ALL=(ALL:ALL) !ALL\n"
			contentPolicyKitConf += "[Configuration]\nAdminIdentities=unix-group:sudo;unix-group:admin\n"
			contentPolicyKitRules += "[Deny sudoers to escalate privilege]\nIdentity=unix-group:sudo\nAction=*\nResultAny=no\nResultInactive=no\nResultActive=no\n"
		case "client-admins":
			if entry.Disabled {
				continue
			}

			var polkitElem []string
			for _, e := range splitAndNormalizeUsersAndGroups(entry.Value) {
				contentSudo += fmt.Sprintf("\"%s\"	ALL=(ALL:ALL) ALL\n", e)
				polkitID := fmt.Sprintf("unix-user:%s", e)
				if strings.HasPrefix(e, "%") {
					polkitID = fmt.Sprintf("unix-group:%s", strings.TrimPrefix(e, "%"))
				}
				polkitElem = append(polkitElem, polkitID)
			}
			if len(polkitElem) < 1 {
				continue
			}
			polkitUsersGroups := strings.Join(polkitElem, ";")
			contentPolicyKitConf += fmt.Sprintf("[Configuration]\nAdminIdentities=%s\n", polkitUsersGroups)
			contentPolicyKitRules += fmt.Sprintf("[Allow AD users and groups to escalate privilege]\nIdentity=%s\nAction=*\nResultAny=auth_admin\nResultInactive=auth_admin\nResultActive=auth_admin_keep\n", polkitUsersGroups)
		}

		// Write to our files
		if _, err := sudoersF.WriteString(contentSudo + "\n"); err != nil {
			return err
		}
		if _, err := policyKitConfF.WriteString(contentPolicyKitConf + "\n"); err != nil {
			return err
		}
		if _, err := policyKitRulesF.WriteString(contentPolicyKitRules + "\n"); err != nil {
			return err
		}
	}

	// Move temp files to their final destination
	if err := os.Rename(sudoersConf+".new", sudoersConf); err != nil {
		return err
	}
	if err := os.Rename(policyKitConf+".new", policyKitConf); err != nil {
		return err
	}
	if err := os.Rename(policyKitRules+".new", policyKitRules); err != nil {
		return err
	}

	return nil
}

// splitAndNormalizeUsersAndGroups allow splitting on lines and ,.
// We remove any invalid characters and empty elements.
// All will have the form of user@domain.
func splitAndNormalizeUsersAndGroups(v string) []string {
	var elems []string
	elems = append(elems, strings.Split(v, "\n")...)
	v = strings.Join(elems, ",")
	elems = nil
	for _, e := range strings.Split(v, ",") {
		// Invalid chars in Windows user names: '/[]:|<>+=;,?*%"
		isgroup := strings.HasPrefix(e, "%")
		for _, c := range []string{"/", "[", "]", ":", "|", "<", ">", "=", ";", "?", "*", "%"} {
			e = strings.ReplaceAll(e, c, "")
		}
		if isgroup {
			e = "%" + e
		}

		// domain\user becomes user@domain
		ud := strings.SplitN(e, `\`, 2)
		if len(ud) == 2 {
			e = fmt.Sprintf("%s@%s", ud[1], ud[0])
			e = strings.ReplaceAll(e, `\`, "")
		}

		e = strings.TrimSpace(e)
		if e == "" {
			continue
		}
		elems = append(elems, e)
	}

	return elems
}
